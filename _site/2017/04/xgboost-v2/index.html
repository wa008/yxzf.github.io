<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
    <title>XGBoost解读(2)--近似分割算法 • YXZF's  Blog</title>
    <meta name="description" content="近似分割算法
XGBoost解读(1)–原理中介绍了XGBoost使用exact greedy算法来寻找分割点建树，但是当数据量非常大难以被全部加载进内存时或者分布式环境下时，exact greedy算法将不再合适。因此作者提出近似算法来寻找分割点。近似算法的大致流程见下面的算法。

">
    <meta name="keywords" content="GBDT, XGBoost">
    
    
    	<!-- Twitter Cards -->
	<meta name="twitter:title" content="XGBoost解读(2)--近似分割算法">
	<meta name="twitter:description" content="近似分割算法
XGBoost解读(1)–原理中介绍了XGBoost使用exact greedy算法来寻找分割点建树，但是当数据量非常大难以被全部加载进内存时或者分布式环境下时，exact greedy算法将不再合适。因此作者提出近似算法来寻找分割点。近似算法的大致流程见下面的算法。

">
	
	
	
	<meta name="twitter:card" content="summary">
	<meta name="twitter:image" content="/images/logo.jpg">
	
	<!-- Open Graph -->
	<meta property="og:locale" content="">
	<meta property="og:type" content="article">
	<meta property="og:title" content="XGBoost解读(2)--近似分割算法">
	<meta property="og:description" content="近似分割算法
XGBoost解读(1)–原理中介绍了XGBoost使用exact greedy算法来寻找分割点建树，但是当数据量非常大难以被全部加载进内存时或者分布式环境下时，exact greedy算法将不再合适。因此作者提出近似算法来寻找分割点。近似算法的大致流程见下面的算法。

">
	<meta property="og:url" content="/2017/04/xgboost-v2/">
	<meta property="og:site_name" content="YXZF's  Blog">
    

    <link rel="canonical" href="/2017/04/xgboost-v2/">

    <link href="/atom.xml" type="application/atom+xml" rel="alternate" title="YXZF's  Blog Atom Feed">
    <link href="/sitemap.xml" type="application/xml" rel="sitemap" title="Sitemap">

    <meta name="HandheldFriendly" content="True">
    <meta name="MobileOptimized" content="320">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="cleartype" content="on">

    <style>
    .sliding-menu-content {
      top: 0;
      right: 0;
      text-align: center;
      visibility: hidden;
      height: 100%;
      width: 100%;
      -webkit-transform: translateX(100%);
      -moz-transform: translateX(100%);
      -ms-transform: translateX(100%);
      -o-transform: translateX(100%);
      transform: translateX(100%);
    }
    </style>

    <link rel="stylesheet" href="/css/main.css">
    <!-- HTML5 Shiv and Media Query Support for IE -->
    <!--[if lt IE 9]>
      <script src="/js/vendor/html5shiv.min.js"></script>
      <script src="/js/vendor/respond.min.js"></script>
    <![endif]-->

  </head>

  <body>
    <header id="masthead">
  <div class="inner-wrap">
    <a href="/" class="site-title">YXZF's  Blog</a>
    <nav role="navigation" class="menu top-menu">
        <ul class="menu-item">
	<li class="home"><a href="/">YXZF's  Blog</a></li>
	
    
        
    
    <li><a href="/" >主页</a></li>
  
    
        
    
    <li><a href="/datamining/" >数据挖掘</a></li>
  
    
        
    
    <li><a href="/deeplearning/" >深度学习</a></li>
  
    
        
    
    <li><a href="/development/" >开发</a></li>
  
    
        
    
    <li><a href="/math/" >数学</a></li>
  
    
        
    
    <li><a href="/about/" >关于</a></li>
  
</ul>
    </nav>
  </div><!-- /.inner-wrap -->
</header><!-- /.masthead -->
    <nav role="navigation" class="js-menu sliding-menu-content">
    <ul class="menu-item">
        <li>
      
        
      
            
            <a href="/" class="title">主页</a>
            
        </li><li>
      
        
      
            
            <a href="/datamining/" class="title">数据挖掘</a>
            
        </li><li>
      
        
      
            
            <a href="/deeplearning/" class="title">深度学习</a>
            
        </li><li>
      
        
      
            
            <a href="/development/" class="title">开发</a>
            
        </li><li>
      
        
      
            
            <a href="/math/" class="title">数学</a>
            
        </li><li>
      
        
      
            
            <a href="/about/" class="title">关于</a>
            
        </li>
    </ul>
</nav>
<button type="button" class="js-menu-trigger sliding-menu-button menulines-button x2" role="button" aria-label="Toggle Navigation">
    <span class="menulines"></span>
</button>

<div class="js-menu-screen menu-screen"></div>


    <div id="page-wrapper">
      <!--[if lt IE 9]><div class="upgrade notice-danger"><strong>Your browser is quite old!</strong> Why not <a href="http://whatbrowser.org/">upgrade to a newer one</a> to better enjoy this site?</div><![endif]-->

      <div id="main" role="main">
    <article class="wrap" itemscope itemtype="http://schema.org/Article">
        
        <div class="page-title">
            <h1>XGBoost解读(2)--近似分割算法</h1>
        </div>
        <div class="inner-wrap">
            
            <div id="content" class="page-content" itemprop="articleBody">
                <h1 id="section">近似分割算法</h1>
<p><a href="https://yxzf.github.io/2017/03/xgboost-v1/">XGBoost解读(1)–原理</a>中介绍了XGBoost使用exact greedy算法来寻找分割点建树，但是当数据量非常大难以被全部加载进内存时或者分布式环境下时，exact greedy算法将不再合适。因此作者提出近似算法来寻找分割点。近似算法的大致流程见下面的算法。</p>

<p><img src="/images/datamining/xgboost_fig/tree_split1.png" alt="" /></p>

<p>对于某个特征$k$，算法首先根据特征分布的分位数找到切割点的候选集合<script type="math/tex">S_k = \{s_{k1}, s_{k2}, ... ,s_{kl} \}</script>；然后将特征$k$的值根据集合$S_k$划分到桶(bucket)中，接着对每个桶内的样本统计值$G$、$H$进行累加统计，最后在这些累计的统计量上寻找最佳分裂点。从算法伪代码可以看出近似算法的核心是如何<strong>根据分位数采样得到分割点的候选集合$S$</strong>.  本文接下来的内容也是围绕这个进行阐述。 </p>

<h1 id="quantile">Quantile</h1>
<p>## $\phi$-quantile<br />
<a href="http://www.mathcs.emory.edu/~cheung/Courses/584-StreamDB/Syllabus/08-Quantile/Greenwald.html">Quantile</a>就是ranking。如果有N个元素，那么$\phi$-quantile就是指rank在$\lfloor \phi \times N \rfloor$的元素。例如$S=[11, 21, 24, 61, 81, 39, 89, 56, 12, 51]$，首先排序为$[11, 12,  21,  24,  39,  51,  56,  61,  81,  89]$，则0.1-quantile=11, 0.5-quantile=39. 上面的是exact quantile寻找方法，如果数据集非常大，难以排序，则需要引入$\epsilon$-approximate $\phi$-quantiles</p>

<h2 id="epsilon-approximate-phi-quantiles">$\epsilon$-approximate $\phi$-quantiles</h2>
<p>也就是$\phi$-quantile是在区间$[ \lfloor (\phi - \epsilon) \times N \rfloor, \lfloor (\phi + \epsilon) \times N \rfloor]$。还是上面的例子，领$\epsilon=0.1$，则有0.2-quantile={11, 12, 21}</p>

<h1 id="weighted--datasets">Weighted  Datasets</h1>
<p>回到XGBoost的建树过程，在建立第$i$棵树的时候已经知道数据集在前面$i-1$棵树的误差，因此采样的时候是需要考虑误差，对于误差大的特征值采样粒度要加大，误差小的特征值采样粒度可以减小，也就是说采样的样本是需要权重的。</p>

<p>重新审视目标函数</p>

<script type="math/tex; mode=display">
\begin{equation}
\sum_{i=1}^n [g_i f_t(x_i) + \frac{1}{2} h_i f_t^2(x_i)] + \Omega(f_t)
\end{equation}
</script>

<p>通过配方可以得到</p>

<script type="math/tex; mode=display">
\begin{equation}
\sum_{1}^n \left[ \frac {1}{2}  h_i \left( f_t(x_i) - (-g_i/h_i)\right)^2 \right] + \Omega (f_t) + constant
\end{equation}
</script>

<p>因此可以将该目标还是看作是关于标签为${-{g_i}/{h_i}}$和权重为$h_i$的平方误差形式。<br />
&gt; 论文中$\frac{g_i}{h_i}$前面没有负号，可是通过推导我认为这种形式才是对的。当然这边的符号不影响论文中其他表达的正确性</p>

<h2 id="h">二阶导数h为权重的解释</h2>
<p>如果损失函数是Square loss，即$Loss(y, \widehat y) = (y - \widehat y)^2$，则$h=2$，那么实际上是不带权。<br />
如果损失函数是Log loss，则$h=pred* (1 - pred)$. 这是个开口朝下的一元二次函数，所以最大值在0.5。当pred在0.5附近，这个值是非常不稳定的，很容易误判，h作为权重则因此变大，那么直方图划分，这部分就会被切分的更细</p>

<p><img src="/images/datamining/xgboost_fig/weighted.png" alt="" /></p>

<h2 id="section-1">问题转换</h2>
<p>记</p>

<script type="math/tex; mode=display">
\begin{equation}
D_k = \{(x_{1k}, h_1), (x_{2k}, h_2), \cdots (x_{nk}, h_n)\}
\end{equation}
</script>

<p>表示 每个训练样本的第$k$维特征值和对应二阶导数。接下来定义排序函数为$r_k(\cdot):R \rightarrow[0, +\infty)$</p>

<script type="math/tex; mode=display">% <![CDATA[

\begin{equation}
r_k (z) = \frac {1} {\sum\limits_{\left( {x,h} \right) \in {D_k}} h } \sum\limits_{\left( {x,h} \right) \in {D_k},x < z} h 
\end{equation}
 %]]></script>

<p>函数表示特征的值小于$z$的样本分布占比，其中二阶导数$h$可以视为权重，后面论述。在这个排序函数下，我们找到一组点<script type="math/tex"> \{ s_{k1}, s_{k2}, ... ,s_{kl} \} </script> ,满足：</p>

<script type="math/tex; mode=display">
\begin{equation}
s_{k,j}
\end{equation}
</script>

<p>其中，${s<em>{k1}} = \mathop {\min }\limits_i {x</em>{ik}},{s<em>{kl}} = \mathop {\max }\limits_i {x</em>{ik}}$。$\varepsilon$为采样率，直观上理解，我们最后会得到$1/\varepsilon$个分界点。</p>

<p>对于每个样本都有相同权重的问题，有quantile sketch算法解决该问题，作者提出Weighted Quantile Sketch算法解决这种weighted datasets的情况。具体算法描述和推理在论文的<a href="http://homes.cs.washington.edu/~tqchen/pdf/xgboost-supp.pdf">补充材料</a>。</p>

<h1 id="weighted-quantile-sketch">Weighted Quantile Sketch</h1>
<p>## Formalization<br />
给定一个multi-set <script type="math/tex">D = \left\{ {\left( ,{w_1}} \right),\left( ,{w_2}} \right) \cdots \left( ,{w_n}} \right)} \right\}$, $w_i\in [0, +\infty], x_i \in \mathcal{X}</script>. 如果数据集D是根据$\mathcal{X}$上的升序进行排列，作者定义了两个rank function <br />
<script type="math/tex">% <![CDATA[
r_{D}^{-} = \sum_{(x, w)\in D, x<y} w %]]></script>, <br />
<script type="math/tex">r_{D}^{+} = \sum_{(x, w)\in D, x\leq y} w</script><br />
注意到$D$是个multi-set，因此会有一些数据具有相同的$x$和$w$，作者还定义了weight function <br />
<script type="math/tex">w_{D}(y) = r_{D}^{+}(y) - r_{D}^{-}(y) = \sum_{(x,w)\in D, x=y}w</script>. 样本集合D上的全部权重定义为<br />
<script type="math/tex">w(D) = \sum_{(x, w)\in D} w</script></p>

<h2 id="quantile-summary-of-weighted-data">Quantile Summary of Weighted Data</h2>
<p>根据上面定义的概念和符号引出Quantile Summary of Weighted Data的定义<br />
数据集$D$上的quantile summary被定义为$Q(D) = (S, \tilde{r}<em>{D}^{+}, \tilde{r}</em>{D}^{-}, \tilde{w}<em>{D})$, 其中集合$S={x_1,x_2,…, x_k}$从D中选出($x_i\in {x|(x_w)\in D}$). S中的元素需要满足下面的性质:<br />
    1 $x_i &lt; x</em>{i+1}$ 对所有的$i$成立。并且$x_1$和$x_k$分别是$D$中的最小和最大点:<br />
<script type="math/tex">x_1=min_{(x,w)\in D} x \quad\quad x_k=max_{(x,w)\in D} x</script><br />
    2 函数$\tilde{r}<em>{D}^{+}, \tilde{r}</em>{D}^{-}, \tilde{w}<em>{D}$是定义在集合$S$上的函数，并且满足<br />
$\tilde{r}</em>{D}^{-}(x_i) \leq r<em>{D}^{-}(x_i)$， $\tilde{r}</em>{D}^{+}(x_i) \leq r<em>{D}^{+}(x_i)$， $\tilde{w}</em>{D}(x_i) \leq w_{D}(x_i)$</p>

<p>$\tilde{r}<em>{D}^{-}(x_i) + \tilde{w}</em>{S}(x_i) \leq \tilde{r}<em>{D}^{-} (x</em>{i+1})$,  $\tilde{r}<em>{D}^{+}(x_i) \leq \tilde{r}</em>{D}^{+}(x<em>{i+1}) - \tilde{w}</em>{D}(x_{i+1})$</p>

<h2 id="varepsilon-approximate-qunatile-summary">$\varepsilon$-Approximate Qunatile Summary</h2>
<p>给定的quantile summary $Q(D)=(S, \tilde{r}<em>{D}^{+}, \tilde{r}</em>{D}^{-}, \tilde{w}<em>{D})$, $Q(D)$被称为$\varepsilon$-Approximate Qunatile summay，当且仅当 $\tilde{r}</em>{D}^{+}(y)-\tilde{r}<em>{D}^{-}(y)-\tilde{w}</em>{D}(y) \leq \varepsilon w(S)$ 对于任意一个$y\in X$成立.<br />
意思也就是说我们对$r<em>{y}^{+}$、$r</em>{y}^{-}$的估计的最大error至多为$\varepsilon w(D)$</p>

<h2 id="varepsilon-approximate-qunatile-summary-1">构建$\varepsilon$-Approximate Qunatile Summary</h2>
<p>### 初始化<br />
在小规模数据集$D = \left{ {\left( ,{w_1}} \right),\left( ,{w_2}} \right) \cdots \left( ,{w_n}} \right)} \right}$上构建初始的quantile summary $Q(D) = (S, \tilde{r}<em>{D}^{+}, \tilde{r}</em>{D}^{-}, \tilde{w}<em>{D})$，集合$S$满足：$S={x|(x,w)\in D}$. $\tilde{r}</em>{D}^{+}, \tilde{r}<em>{D}^{-}, \tilde{w}</em>{D}$被定义为<br />
$\tilde{r}<em>{D}^{-}(x) = r</em>{D}^{-}(x)$， $\tilde{r}<em>{D}^{+}(x) = r</em>{D}^{+}(x)$， $\tilde{w}<em>{D}(x) = w</em>{D}(x)  \quad for \quad  x\in S$<br />
可以看出，初始的$Q(D)$是0-approximate summary.</p>

<h3 id="merge-operation">Merge Operation</h3>
<p>$Q(D_1)=(S_1, \tilde{r}<em>{D_1}^{+}, \tilde{r}</em>{D_1}^{-}, \tilde{w}<em>{D</em>{1}})$和$Q(D_2)=(S_1, \tilde{r}<em>{D_2}^{+}, \tilde{r}</em>{D_2}^{-}, \tilde{w}<em>{D</em>{2}})$分别定义在数据集$D1$和$D2$上，令$D=D_1\cup D_2$，那么merged summary $Q(D)=(S, \tilde{r}<em>{D}^{+}, \tilde{r}</em>{D}^{-}, \tilde{w}<em>D)$被定义为：<br />
* $S={(x_1, x_2, …, x_k)}, \quad x_i\in S_1 \quad or \quad s_i \in S_2$<br />
* $\tilde{r}</em>{D}^{-}(x_i) = \tilde{r}<em>{D_1}^{-}(x_i) + \tilde{r}</em>{D_2}^{-}(x_i) $<br />
* $\tilde{r}<em>{D}^{+}(x_i) = \tilde{r}</em>{D_1}^{+}(x_i) + \tilde{r}<em>{D_2}^{+}(x_i) $<br />
* $\tilde{w}</em>{D}(x_i) = \tilde{w}<em>{D_1}(x_i) + \tilde{w}</em>{D_2}(x_i) $</p>

<h3 id="prune-operation">Prune Operation</h3>
<p>给定$Q(D)=(S, \tilde{r}<em>{D}^{+}, \tilde{r}</em>{D}^{-}, \tilde{w}<em>{D})$(其中$S={x_1, x_2, …, x_k}$)和memory budget $b$，prune operation构建一个新的summary, $\acute{Q}(D)=(\acute{S}, \tilde{r}</em>{D}^{+}, \tilde{r}<em>{D}^{-}, \tilde{w}</em>{D})$. $\acute{D}$中的$\tilde{r}<em>{D}^{+}, \tilde{r}</em>{D}^{-}, \tilde{w}<em>{D}$定义与原先的summary $Q$一致，只是定义域从$S$变为$\acute{S}$, $\acute{S}={\acute{x_1}, \acute{x_2}, …, \acute{x</em>{b+1}}}$,  $\acute{x_i}$的选择按照下面的操作获取：<br />
<script type="math/tex">\acute{x_i}=g(Q, \frac{i-1}{b} w(D))</script><br />
$g(Q, d)$是query function，对于给定的quantile summary $Q$和rank $d$, $g(Q, d)$返回一个元素$x$，$x$的rank最接近$d$，具体定义为</p>

<p><img src="/images/datamining/xgboost_fig/query.png" alt="" /></p>

<h1 id="section-2">参考资料</h1>
<p>http://datascience.stackexchange.com/questions/10997/need-help-understanding-xgboosts-approximate-split-points-proposal</p>


                <hr />
                <footer class="page-footer">
                    


<div class="author-image">
	<img src="/images/logo.jpg" alt="沈成光">
</div><!-- ./author-image -->
<div class="author-content">
	<h3 class="author-name" >Written by <span itemprop="author">沈成光</span></h3>
	<p class="author-bio"></p>
</div><!-- ./author-content -->
                    <div class="inline-btn">
    <a class="btn-social twitter" href="https://twitter.com/intent/tweet?text=XGBoost解读(2)--近似分割算法&amp;url=/2017/04/xgboost-v2/&amp;via=" target="_blank"><i class="fa fa-twitter" aria-hidden="true"></i> Share on Twitter</a> 
<!-- <a class="btn-social twitter" href="http://service.weibo.com/share/share.php?title=XGBoost解读(2)--近似分割算法&url=/2017/04/xgboost-v2/&changweibo=yes&ralateUid=1278841597" target='_newtab' type="submit" class="submit">分享到微博</a> -->
    <a class="btn-social facebook" href="https://www.facebook.com/sharer/sharer.php?u=/2017/04/xgboost-v2/" target="_blank"><i class="fa fa-facebook" aria-hidden="true"></i> Share on Facebook</a>
    <a class="btn-social google-plus"  href="https://plus.google.com/share?url=/2017/04/xgboost-v2/" target="_blank"><i class="fa fa-google-plus" aria-hidden="true"></i> Share on Google+</a>
</div><!-- /.share-this -->

                    <div class="page-meta">
	<p>Updated <time datetime="2017-04-16T00:00:00Z" itemprop="datePublished">April 16, 2017</time></p>
</div><!-- /.page-meta -->
                </footer><!-- /.footer -->
                <!-- JiaThis Button BEGIN -->
<div class="jiathis_style_32x32">
    <a class="jiathis_button_weixin"></a>
    <a class="jiathis_button_tsina"></a>
    <a class="jiathis_button_tqq"></a>
    <a class="jiathis_button_qzone"></a>
    <a href="http://www.jiathis.com/share" class="jiathis jiathis_txt jtico jtico_jiathis" target="_blank"></a>
    <a class="jiathis_counter_style"></a>
</div>
<script type="text/javascript" src="http://v3.jiathis.com/code/jia.js" charset="utf-8"></script>
<!-- JiaThis Button END -->

                <aside>
                    <section class="comment">
<!-- baidu JIA -->
<div class="bdsharebuttonbox"><a href="#" class="bds_more" data-cmd="more"></a><a title="分享到QQ空间" href="#" class="bds_qzone" data-cmd="qzone"></a><a title="分享到新浪微博" href="#" class="bds_tsina" data-cmd="tsina"></a><a title="分享到腾讯微博" href="#" class="bds_tqq" data-cmd="tqq"></a><a title="分享到人人网" href="#" class="bds_renren" data-cmd="renren"></a><a title="分享到微信" href="#" class="bds_weixin" data-cmd="weixin"></a></div>
<script>window._bd_share_config={"common":{"bdSnsKey":{},"bdText":"","bdMini":"2","bdMiniList":false,"bdPic":"","bdStyle":"1","bdSize":"16"},"share":{}};with(document)0[(getElementsByTagName('head')[0]||body).appendChild(createElement('script')).src='http://bdimg.share.baidu.com/static/api/js/share.js?v=89860593.js?cdnversion='+~(-new Date()/36e5)];</script>
<!-- end of baidu JIA -->

<!-- 多说评论框 start -->
    <div class="ds-thread" data-thread-key="/2017/04/xgboost-v2/" data-title="XGBoost解读(2)--近似分割算法" data-url="/2017/04/xgboost-v2/"></div>
<!-- 多说评论框 end -->
<!-- 多说公共JS代码 start (一个网页只需插入一次) -->
<script type="text/javascript">
var duoshuoQuery = {short_name:"yxzf"};
    (function() {
        var ds = document.createElement('script');
        ds.type = 'text/javascript';ds.async = true;
        ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
        ds.charset = 'UTF-8';
        (document.getElementsByTagName('head')[0] 
         || document.getElementsByTagName('body')[0]).appendChild(ds);
    })();
    </script>
<!-- 多说公共JS代码 end -->


</section>

                </aside>
            </div><!-- /.content -->
        </div><!-- /.inner-wrap -->
        <div class="ads"><script src="//about.me/chengguang.shen"></script>
</div>
    </article><!-- ./wrap -->
</div><!-- /#main -->
<script>
      (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
      })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

      ga('create', 'UA-57330114-1', 'auto');
      ga('send', 'pageview');
</script>

<script>
    var _hmt = _hmt || [];
    (function() {
           var hm = document.createElement("script");
             hm.src = "//hm.baidu.com/hm.js?138fcb8c5448d0003de5abef31cdd0b9";
               var s = document.getElementsByTagName("script")[0]; 
                 s.parentNode.insertBefore(hm, s);
                 })();
</script>


<script type="text/javascript"
     src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
     MathJax.Hub.Config({
       extensions: ["tex2jax.js","TeX/noErrors.js","TeX/AMSsymbols.js"],
       jax: ["input/TeX","output/HTML-CSS"],
       tex2jax: {
         inlineMath: [['$','$'],["\\(","\\)"]],
         displayMath: [['\\[','\\]'], ['$$','$$']],
         balanceBraces: true
       },
       TeX: {equationNumbers: {autoNumber: ["AMS"], useLabelIds: true}},
       "HTML-CSS": {availableFonts:["TeX"]},
       });
      MathJax.Hub.Queue(["Typeset",MathJax.Hub]);
</script>


      <footer role="contentinfo" id="site-footer">
	<nav role="navigation" class="menu bottom-menu">
		<ul class="menu-item">
		
      
        
      
			<li><a href="" ></a></li>
		
		</ul>
	</nav><!-- /.bottom-menu -->
	<p class="copyright">&#169; 2017 <a href="">YXZF's  Blog</a> powered by <a href="http://jekyllrb.com" rel="nofollow">Jekyll</a> + <a href="http://mmistakes.github.io/skinny-bones-jekyll/" rel="nofollow">Skinny Bones</a>.</p>
</footer>
    </div>

    <script src="/js/vendor/jquery-1.9.1.min.js"></script>
    <script src="/js/main.js"></script>
    
    

  </body>

</html>
